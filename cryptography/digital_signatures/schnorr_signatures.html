<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Signature Aggregation - Tari University</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A collection of learning resources for cryptocurrency">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true
            }
          });
        </script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "../../";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="../../cryptography/cryptography.html"><strong aria-hidden="true">1.</strong> Cryptography</a></li><li><ol class="section"><li><a href="../../cryptography/crypto-1/sources/PITCHME.link.html"><strong aria-hidden="true">1.1.</strong> Elliptic curves 101</a></li><li><a href="../../cryptography/digital_signatures/introduction.html"><strong aria-hidden="true">1.2.</strong> Introduction to Schnorr signatures</a></li><li><ol class="section"><li><a href="../../cryptography/digital_signatures/basics.html"><strong aria-hidden="true">1.2.1.</strong> Basics of Schnorr signatures</a></li><li><a href="../../cryptography/digital_signatures/schnorr_signatures.html" class="active"><strong aria-hidden="true">1.2.2.</strong> Signature Aggregation</a></li></ol></li><li><a href="../../cryptography/scriptless-scripts/introduction-to-scriptless-scripts.html"><strong aria-hidden="true">1.3.</strong> Introduction to Scriptless Scripts</a></li></ol></li><li><a href="../../consensus-mechanisms/consensus-mechanisms.html"><strong aria-hidden="true">2.</strong> Consensus Mechanisms</a></li><li><ol class="section"><li><a href="../../consensus-mechanisms/BFT-consensusmechanisms/sources/PITCHME.link.html"><strong aria-hidden="true">2.1.</strong> BFT Consensus Mechanisms</a></li></ol></li><li><a href="../../layer2scaling/layer2scaling.html"><strong aria-hidden="true">3.</strong> Layer 2 Scaling</a></li><li><ol class="section"><li><a href="../../layer2scaling/layer2scaling-landscape/layer2scaling-survey.html"><strong aria-hidden="true">3.1.</strong> Layer 2 Scaling Survey (part 1)</a></li><li><a href="../../layer2scaling/more-landscape/landscape-update.html"><strong aria-hidden="true">3.2.</strong> Layer 2 Scaling Survey (part 2)</a></li><li><a href="../../layer2scaling/executive-summary/sources/PITCHME.link.html"><strong aria-hidden="true">3.3.</strong> Executive Summary</a></li></ol></li><li><a href="../../merged-mining/merged-mining.html"><strong aria-hidden="true">4.</strong> Merged Mining</a></li><li><ol class="section"><li><a href="../../merged-mining/merged-mining-scene/MergedMiningIntroduction.html"><strong aria-hidden="true">4.1.</strong> Merged Mining Introduction</a></li></ol></li><li><a href="../../non-fungible-tokens/non-fungible-tokens.html"><strong aria-hidden="true">5.</strong> Non-fungible Tokens</a></li><li><ol class="section"><li><a href="../../non-fungible-tokens/nft-landscape-1/sources/PITCHME.link.html"><strong aria-hidden="true">5.1.</strong> NFT Landscape</a></li></ol></li><li><a href="../../protocols/protocols.html"><strong aria-hidden="true">6.</strong> Protocols</a></li><li><ol class="section"><li><a href="../../protocols/mimblewimble-1/sources/PITCHME.link.html"><strong aria-hidden="true">6.1.</strong> Mimblewimble</a></li><li><a href="../../protocols/atomic-swaps/AtomicSwaps.html"><strong aria-hidden="true">6.2.</strong> Atomic Swaps</a></li><li><a href="../../protocols/lightning-network-for-dummies/sources/PITCHME.link.html"><strong aria-hidden="true">6.3.</strong> Lightning Network for Dummies</a></li><li><a href="../../protocols/merkle-trees-and-spv-1/sources/PITCHME.link.html"><strong aria-hidden="true">6.4.</strong> Introduction to SPV, Merkle Trees and Bloom Filters</a></li><li><a href="../../protocols/rgb-introduction/sources/PITCHME.link.html"><strong aria-hidden="true">6.5.</strong> The RGB Protocol - An Introduction</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Tari University</h1> 

                        <div class="right-buttons">
                            <a href="../../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#schnorr-signatures" id="schnorr-signatures"><h1>Schnorr signatures</h1></a>
<p>If you follow the crypto news, you'll know that that new hotness in Bitcoin is Schnorr Signatures.</p>
<p><img src="./img/schnorr-meme.jpg" alt="schnorr" /></p>
<p>But in actual fact, they're old news! The Schnorr signature is considered the simplest digital signature scheme
to be provably secure in a random oracle model. It is efficient and generates short signatures.
It was covered by U.S. Patent 4,995,082 which expired in February 2008 [<a href="https://en.wikipedia.org/wiki/Schnorr_signature" title="Wikipedia:Schnorr signature">1</a>].</p>
<a class="header" href="#so-why-all-the-fuss" id="so-why-all-the-fuss"><h2>So why all the fuss?</h2></a>
<p>What makes Schnorr signatures so interesting, and <a href="#key-cancellation-attack">potentially dangerous</a>, is their simplicity.
Schnorr signatures are <em>linear</em>, so you have some nice properties.</p>
<p>Elliptic curves have the multiplicative property. So if you have two scalars <em>x, y</em> with corresponding points, <em>X, Y</em>,
the following holds:</p>
<p>$$
(x + y)G = xG + yG = X + Y
$$</p>
<p>Schnorr signatures are of the form \( s = r + e.k \). This construction is linear too, so it fits nicely with
the linearity of elliptic curve math.</p>
<p>You saw this property in the previous section, when we were verifying the signature. Schnorr signatures' linearity
makes it very attractive for things like</p>
<ul>
<li>signature aggregation</li>
<li><a href="../../protocols/atomic-swaps/AtomicSwaps.html">atomic swaps</a></li>
<li><a href="../scriptless-scripts/introduction-to-scriptless-scripts.html">'scriptless' scripts</a></li>
</ul>
<a class="header" href="#naïve-signature-aggregation" id="naïve-signature-aggregation"><h2>(Naïve) Signature aggregation</h2></a>
<p>Let's see how the linearity property of Schnorr signatures can be used to construct a 2-of-2 multi-signature.</p>
<p>Alice and Bob want to co-sign something (a Tari transaction, say) without having to trust each other;
i.e. they need to be able to prove ownership of their respective keys, and the aggregate signature is
only valid if <em>both</em> Alice and Bob provide their part of the signature.</p>
<p>Assuming private keys are denoted \( k_i \) and public keys \( P_i \). If we ask Alice and Bob to each
supply a nonce, we can try:</p>
<p>$$
\begin{align}
P_{agg} &amp;= P_a + P_b \\
e &amp;= H(R_a || R_b || P_a || P_b || m) \\
s_{agg} &amp;= r_a + r_b + (k_a + k_b)e \\
&amp;= (r_a + k_ae) + (r_b + k_ae) \\
&amp;= s_a + s_b
\end{align}
$$</p>
<p>So it looks like Alice and Bob can supply their own <em>R</em>, and anyone can construct the 2-of-2 signature
from the sum of the <em>Rs</em> and public keys. This does work:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate libsecp256k1_rs as secp256k1;

use secp256k1::{SecretKey, PublicKey, thread_rng, Message};
use secp256k1::schnorr::{Schnorr, Challenge};

#[allow(non_snake_case)]
fn main() {
    // Alice generates some keys
    let (ka, Pa, ra, Ra) = get_keyset();
    // Bob generates some keys
    let (kb, Pb, rb, Rb) = get_keyset();
    let m = Message::hash(b&quot;a multisig transaction&quot;).unwrap();
    // The challenge uses both nonce public keys and private keys
    // e = H(Ra || Rb || Pa || Pb || H(m))
    let e = Challenge::new(&amp;[&amp;Ra, &amp;Rb, &amp;Pa, &amp;Pb, &amp;m]).as_scalar().unwrap();
    // Alice calculates her signature
    let sa = ra + ka * e;
    // Bob calculates his signature
    let sb = rb + kb * e;
    // Calculate the aggregate signature
    let s_agg = sa + sb;
    // S = s_agg.G
    let S = PublicKey::from_secret_key(&amp;s_agg);
    // This should equal Ra + Rb + e(Pa + Pb)
    assert_eq!(S, Ra + Rb + e*(Pa + Pb));
    println!(&quot;The aggregate signature is valid!&quot;)
}

#[allow(non_snake_case)]
fn get_keyset() -&gt; (SecretKey, PublicKey, SecretKey, PublicKey) {
    let mut rng = thread_rng();
    let k = SecretKey::random(&amp;mut rng);
    let P = PublicKey::from_secret_key(&amp;k);
    let r = SecretKey::random(&amp;mut rng);
    let R = PublicKey::from_secret_key(&amp;r);
    (k, P, r, R)
}

</code></pre></pre>
<p>But this scheme is not secure!</p>
<a class="header" href="#key-cancellation-attack" id="key-cancellation-attack"><h2>Key cancellation attack</h2></a>
<p>Let's take the previous scenario again, but this time, Bob knows Alice's public key and nonce ahead of time, by
waiting until she reveals them.</p>
<p>Now Bob lies, and says that his public key is \( P_b' = P_b - P_a \) and public nonce is \( R_b' = R_b - R_a \).</p>
<p>Note that Bob doesn't know the private keys for these faked values, but that doesn't matter.</p>
<p>Everyone assumes that \(s_{agg} = R_a + R_b' + e(P_a + P_b') \) as per the aggregation scheme.</p>
<p>But Bob can create this signature himself:</p>
<p>$$
\begin{align}
s_{agg}G &amp;= R_a + R_b' + e(P_a + P_b') \\
&amp;= R_a + (R_b - R_a) + e(P_a + P_b - P_a) \\
&amp;= R_b + eP_b \\
&amp;= r_bG + ek_bG \\
\therefore s_{agg} &amp;= r_b + ek_b = s_b
\end{align}
$$</p>
<pre><pre class="playpen"><code class="language-rust">extern crate libsecp256k1_rs as secp256k1;

use secp256k1::{SecretKey, PublicKey, thread_rng, Message};
use secp256k1::schnorr::{Schnorr, Challenge};

#[allow(non_snake_case)]
fn main() {
    // Alice generates some keys
    let (ka, Pa, ra, Ra) = get_keyset();
    // Bob generates some keys as before
    let (kb, Pb, rb, Rb) = get_keyset();
    // ..and then publishes his forged keys
    let Pf = Pb - Pa;
    let Rf = Rb - Ra;

    let m = Message::hash(b&quot;a multisig transaction&quot;).unwrap();
    // The challenge uses both nonce public keys and private keys
    // e = H(Ra || Rb' || Pa || Pb' || H(m))
    let e = Challenge::new(&amp;[&amp;Ra, &amp;Rf, &amp;Pa, &amp;Pf, &amp;m]).as_scalar().unwrap();

    // Bob creates a forged signature
    let s_f = rb + e * kb;
    // Check if it's valid
    let sG = Ra + Rf + e*(Pa + Pf);
    assert_eq!(sG, PublicKey::from_secret_key(&amp;s_f));
    println!(&quot;Bob successfully forged the aggregate signature!&quot;)
}

#[allow(non_snake_case)]
fn get_keyset() -&gt; (SecretKey, PublicKey, SecretKey, PublicKey) {
    let mut rng = thread_rng();
    let k = SecretKey::random(&amp;mut rng);
    let P = PublicKey::from_secret_key(&amp;k);
    let r = SecretKey::random(&amp;mut rng);
    let R = PublicKey::from_secret_key(&amp;r);
    (k, P, r, R)
}

</code></pre></pre>
<a class="header" href="#better-approaches-to-aggregation" id="better-approaches-to-aggregation"><h2>Better approaches to aggregation</h2></a>
<p>In the key attack above, Bob didn't know the private keys for his published <em>R</em> and <em>P</em> values. We could defeat Bob
by asking him to sign a message proving that he <em>does</em> know the private keys.</p>
<p>This works, but it requires another round of messaging between parties, which is not conducive to a great user experience.</p>
<p>A better approach would be one that incorporates one or more of the following features:</p>
<ul>
<li>Must be provably secure in the plain public-key model, without having to prove knowledge of secret keys, as we might have asked Bob to do in the naïve approach above;</li>
<li>should satisfy the normal Schnorr equation, i.e. the resulting signature can be verified with an expression of the form \( R + e X \).</li>
<li>allows for Interactive Aggregate Signatures (IAS) where the signers are required to cooperate;</li>
<li>allows for Non-interactive Aggregate Signatures (NAS) where the aggregation can be done by anyone;</li>
<li>allow each signer to sign the same message, <em>m</em>;</li>
<li>allow each signer to sign their own message, \( m_i )).</li>
</ul>
<a class="header" href="#musig" id="musig"><h1>MuSig</h1></a>
<p>MuSig is a recently proposed [<a href="https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html" title="Blockstream: Key Aggregation for Schnorr Signatures">2</a>],[<a href="https://eprint.iacr.org/2018/068.pdf" title="Maxwell et. al., Simple Schnorr Multi-Signatures with Applications to Bitcoin">3</a>] simple signature aggregation scheme that satisfies all of the properties above.</p>
<p>We'll demonstrate the interactive MuSig scheme here, where each signatory signs the same message.
The scheme works as follows:</p>
<ol>
<li>Each signer has a public-private key pair as before.</li>
<li>Each signer publishes the public key of their nonce, \( R_i \),</li>
<li>Everyone calculates the same &quot;shared public key&quot;, <em>X</em> as follows:
$$
\begin{align}
\ell &amp;= H(X_1 || \dots || X_n) \\
a_i &amp;= H(\ell || X_i) \\
X &amp;= \sum a_i X_i \\
\end{align}
$$
Note that in the ordering of public keys above, some deterministic convention should be used, such as the lexicographical
order of the serialised keys.</li>
<li>Everyone also calculates the shared nonce, \( R = \sum R_i \).</li>
<li>The challenge, <em>e</em> is \( H(R || X || m) \)</li>
<li>Each signer provides their contribution to the signature as
$$
s_i = r_i + k_i a_i e
$$
Notice that the only departure here from a standard Schnorr signature is the inclusion of the factor \( a_i \).</li>
<li>The aggregate signature is the usual summation, \( s = \sum s_i \).</li>
</ol>
<p>Verification is done by confirming that</p>
<p>$$
sG \equiv R + e X \
$$</p>
<p>as usual. Proof:</p>
<p>$$
\begin{align}
sG &amp;= \sum s_i G \\
&amp;= \sum (r_i + k_i a_i e)G \\
&amp;= \sum r_iG + k_iG a_i e \\
&amp;= \sum R_i + X_i a_i e \\
&amp;= \sum R_i + e \sum a_i X_i \\
&amp;= R + e X \\
\blacksquare
\end{align}
$$</p>
<p>Let's demonstrate this using a three-of-three multisig:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate libsecp256k1_rs as secp256k1;

use secp256k1::{ SecretKey, PublicKey, thread_rng, Message };
use secp256k1::schnorr::{ Challenge };

#[allow(non_snake_case)]
fn main() {
    let (k1, X1, r1, R1) = get_keys();
    let (k2, X2, r2, R2) = get_keys();
    let (k3, X3, r3, R3) = get_keys();

    // I'm setting the order here. In general, they'll be sorted
    let l = Challenge::new(&amp;[&amp;X1, &amp;X2, &amp;X3]);
    // ai = H(l || p)
    let a1 = Challenge::new(&amp;[ &amp;l, &amp;X1 ]).as_scalar().unwrap();
    let a2 = Challenge::new(&amp;[ &amp;l, &amp;X2 ]).as_scalar().unwrap();
    let a3 = Challenge::new(&amp;[ &amp;l, &amp;X3 ]).as_scalar().unwrap();
    // X = sum( a_i X_i)
    let X = a1 * X1 + a2 * X2 + a3 * X3;

    let m = Message::hash(b&quot;SomeSharedMultiSigTx&quot;).unwrap();

    // Calc shared nonce
    let R = R1 + R2 + R3;

    // e = H(R || X || m)
    let e = Challenge::new(&amp;[&amp;R, &amp;X, &amp;m]).as_scalar().unwrap();


    // Signatures
    let s1 = r1 + k1 * a1 * e;
    let s2 = r2 + k2 * a2 * e;
    let s3 = r3 + k3 * a3 * e;
    let s = s1 + s2 + s3;

    //Verify
    let sg = PublicKey::from_secret_key(&amp;s);
    let check = R + e * X;
    assert_eq!(sg, check, &quot;The signature is INVALID&quot;);
    println!(&quot;The signature is correct!&quot;)
}

#[allow(non_snake_case)]
fn get_keys() -&gt; (SecretKey, PublicKey, SecretKey, PublicKey) {
    let mut rng = thread_rng();
    let k = SecretKey::random(&amp;mut rng);
    let P = PublicKey::from_secret_key(&amp;k);
    let r = SecretKey::random(&amp;mut rng);
    let R = PublicKey::from_secret_key(&amp;r);
    (k, P, r, R)
}
</code></pre></pre>
<a class="header" href="#security-demonstration" id="security-demonstration"><h2>Security demonstration</h2></a>
<p>As a final demonstration, let's show how MuSig defeats the cancellation attack from the naïve signature scheme described
above. Using the same idea as in <a href="#key-cancellation-attack">the previous section</a>, Bob has provided fake values for his
nonce and public keys:</p>
<p>$$
\begin{align}
R_f &amp;= R_b - R_a \\
X_f &amp;= X_b - X_a \\
\end{align}
$$</p>
<p>This leads to both Alice and Bob calculating the following &quot;shared&quot; values:</p>
<p>$$
\begin{align}
\ell &amp;= H(X_a || X_f) \\
a_a &amp;= H(\ell || X_a) \\
a_f &amp;= H(\ell || X_f) \\
X &amp;= a_a X_a + a_f X_f \\
R &amp;= R_a + R_f (= R_b) \\
e &amp;= H(R || X || m)
\end{align}
$$</p>
<p>He then tries to construct a unilateral signature following MuSig:</p>
<p>$$
s_b = r_b + k_s e
$$</p>
<p>Let's assume for now that \( k_s \) doesn't need to be Bob's private key, but that he can derive it using information
he knows. For this to be a valid signature, it must verify to \( R + eX \). So therefore</p>
<p>$$
\begin{align}
s_b G          &amp;= R + eX \\
(r_b + k_s e)G &amp;= R_b + e(a_a X_a + a_f X_f) &amp; \text{The first term looks good so far}\\
&amp;= R_b + e(a_a X_a + a_f X_b - a_f X_a) \\
&amp;= (r_b + e a_a k_a + e a_f k_b - e a_f k_a)G &amp; \text{The r terms cancel as before} \\
k_s e &amp;=  e a_a k_a + e a_f k_b - e a_f k_a &amp; \text{But nothing else is going away}\\
k_s &amp;= a_a k_a + a_f k_b - a_f k_a \\<br />
\end{align}
$$</p>
<p>In the previous attack, Bob had all the information he needed on the right-hand side of the analogous calculation. In MuSig,
Bob must somehow know Alice's private key and the faked private key (the terms don't cancel anymore) in order to create a unilateral signature
and so his cancellation attack is defeated.</p>
<a class="header" href="#references" id="references"><h1>References</h1></a>
<ul>
<li>[<a href="https://en.wikipedia.org/wiki/Schnorr_signature" title="Wikipedia:Schnorr signature">1</a>]: Schnorr signature, Wikipedia, <em>https://en.wikipedia.org/wiki/Schnorr_signature</em>, Date accessed: 19 September 2018</li>
<li>[<a href="https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html" title="Blockstream: Key Aggregation for Schnorr Signatures">2</a>]: Key Aggregation for Schnorr Signatures, Blockstream, <em>https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html</em>, Date accessed: 19 September 2018</li>
<li>[<a href="https://eprint.iacr.org/2018/068.pdf" title="Maxwell et. al., Simple Schnorr Multi-Signatures with Applications to Bitcoin">3</a>]: Simple Schnorr Multi-Signatures with Applications to Bitcoin, Maxwell <em>et. al.</em>, <em>https://eprint.iacr.org/2018/068.pdf</em></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../cryptography/digital_signatures/basics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../cryptography/scriptless-scripts/introduction-to-scriptless-scripts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../../cryptography/digital_signatures/basics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../../cryptography/scriptless-scripts/introduction-to-scriptless-scripts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        <script src="../../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
